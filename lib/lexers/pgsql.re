/**
 * Portions Copyright (c) 1996-2015, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *    src/backend/parser/scan.l
 **/

#include <stddef.h> /* offsetof */
#include <stdlib.h>
#include <string.h>

#include "utils.h"
#include "tokens.h"
#include "lexer.h"

typedef struct {
    LexerData data;
    char *dolqstart;
    size_t dolqstart_len;
} PgLexerData;

typedef struct {
    int uppercase_keywords ALIGNED(sizeof(OptionValue));
    int standard_conforming_strings ALIGNED(sizeof(OptionValue));
} PgLexerOption;

enum {
    STATE(INITIAL),
    STATE(xb),     // bit string literal ([bB]'...')
    STATE(xc),     // extended C-style comments (/* ... */)
    STATE(xd),     // delimited identifiers (double-quoted identifiers) (standard "...")
    STATE(xh),     // hexadecimal numeric string ([xX]'...')
    STATE(xe),     // extended quoted strings (support backslash escape sequences) ([eE]'...' with \x[[:xdigit:]]{2}, \u[[:xdigit:]]{4}, \U[[:xdigit:]]{8}, \[0-7]{1,3} sequences)
    STATE(xq),     // standard quoted strings (standard '...')
    STATE(xdolq),  // dollar quoted strings (($([^$]*$)...\1)
    STATE(xui),    // quoted identifier with Unicode escapes ([uU]&"..." with \[[:xdigit:]]{4} or \+[[:xdigit:]]{6} - \ is the default escape character, it can be changed with a following UESCAPE)
    STATE(xuiend), // end of a quoted identifier with Unicode escapes, UESCAPE can follow
    STATE(xus),    // quoted string with Unicode escapes (simply the same as xui with ' as delimiter instead of ")
    STATE(xusend), // end of a quoted string with Unicode escapes, UESCAPE can follow
    STATE(xeu)     // Unicode surrogate pair in extended quoted string (just a "virtual" state to expect an UTF-16 trailing surrogate pair, shall don't check it?)
};

enum {
    UNRESERVED_KEYWORD,
    COL_NAME_KEYWORD,
    TYPE_FUNC_NAME_KEYWORD,
    RESERVED_KEYWORD
};

/**
 * TODO: recognize the "sequences" (as a whole instead of word by word)?
 * - 'DOUBLE' whitespace+ 'PRECISION'
 * - ('BIT' | 'CHARACTER') whitespace+ 'VARYING'
 * - 'TIME' 'STAMP'? ((whitespace*"('" <a constant?> "')"whitespace*)? | whitespace+) ('WITH' 'OUT'? whitespace* 'TIME' whitespace* 'ZONE')?
 **/
#define PG_TYPE(name) \
    { NE(name), KEYWORD_TYPE },
// PG_KEYWORD\(("[^"]*"),[^,]+,([^)]+)\) => PG_KEYWORD(\1,\2)
#define PG_KEYWORD(name, category) \
    { NE(name), KEYWORD },
static const typed_named_element_t keywords[] = {
    PG_KEYWORD("ABORT", UNRESERVED_KEYWORD)
    PG_KEYWORD("ABSOLUTE", UNRESERVED_KEYWORD)
    PG_KEYWORD("ACCESS", UNRESERVED_KEYWORD)
    PG_KEYWORD("ACTION", UNRESERVED_KEYWORD)
    PG_KEYWORD("ADD", UNRESERVED_KEYWORD)
    PG_KEYWORD("ADMIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("AFTER", UNRESERVED_KEYWORD)
    PG_KEYWORD("AGGREGATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("ALL", RESERVED_KEYWORD)
    PG_KEYWORD("ALSO", UNRESERVED_KEYWORD)
    PG_KEYWORD("ALTER", UNRESERVED_KEYWORD)
    PG_KEYWORD("ALWAYS", UNRESERVED_KEYWORD)
    PG_KEYWORD("ANALYSE", RESERVED_KEYWORD)
    PG_KEYWORD("ANALYZE", RESERVED_KEYWORD)
    PG_KEYWORD("AND", RESERVED_KEYWORD)
    PG_KEYWORD("ANY", RESERVED_KEYWORD)
    PG_TYPE("ANYARRAY")
    PG_KEYWORD("ARRAY", RESERVED_KEYWORD)
    PG_KEYWORD("AS", RESERVED_KEYWORD)
    PG_KEYWORD("ASC", RESERVED_KEYWORD)
    PG_KEYWORD("ASSERTION", UNRESERVED_KEYWORD)
    PG_KEYWORD("ASSIGNMENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("ASYMMETRIC", RESERVED_KEYWORD)
    PG_KEYWORD("AT", UNRESERVED_KEYWORD)
    PG_KEYWORD("ATTRIBUTE", UNRESERVED_KEYWORD)
    PG_KEYWORD("AUTHORIZATION", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("BACKWARD", UNRESERVED_KEYWORD)
    PG_KEYWORD("BEFORE", UNRESERVED_KEYWORD)
    PG_KEYWORD("BEGIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("BETWEEN", COL_NAME_KEYWORD)
    PG_TYPE("BIGINT")
    PG_TYPE("BIGSERIAL")
    // PG_KEYWORD("BIGINT", COL_NAME_KEYWORD)
    PG_KEYWORD("BINARY", TYPE_FUNC_NAME_KEYWORD)
    PG_TYPE("BIT")
    // PG_KEYWORD("BIT", COL_NAME_KEYWORD)
    PG_TYPE("BOOL")
    PG_TYPE("BOOLEAN")
    // PG_KEYWORD("BOOLEAN", COL_NAME_KEYWORD)
    PG_KEYWORD("BOTH", RESERVED_KEYWORD)
    PG_TYPE("BOX")
    PG_KEYWORD("BY", UNRESERVED_KEYWORD)
    PG_TYPE("BYTEA")
    PG_KEYWORD("CACHE", UNRESERVED_KEYWORD)
    PG_KEYWORD("CALLED", UNRESERVED_KEYWORD)
    PG_KEYWORD("CASCADE", UNRESERVED_KEYWORD)
    PG_KEYWORD("CASCADED", UNRESERVED_KEYWORD)
    PG_KEYWORD("CASE", RESERVED_KEYWORD)
    PG_KEYWORD("CAST", RESERVED_KEYWORD)
    PG_KEYWORD("CATALOG", UNRESERVED_KEYWORD)
    PG_KEYWORD("CHAIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("CHAR", COL_NAME_KEYWORD)
    // PG_KEYWORD("CHARACTER", COL_NAME_KEYWORD)
    PG_TYPE("CHARACTER")
    PG_KEYWORD("CHARACTERISTICS", UNRESERVED_KEYWORD)
    PG_KEYWORD("CHECK", RESERVED_KEYWORD)
    PG_KEYWORD("CHECKPOINT", UNRESERVED_KEYWORD)
    PG_TYPE("CIDR")
    PG_TYPE("CIRCLE")
    PG_TYPE("CITEXT")
    PG_KEYWORD("CLASS", UNRESERVED_KEYWORD)
    PG_KEYWORD("CLOSE", UNRESERVED_KEYWORD)
    PG_KEYWORD("CLUSTER", UNRESERVED_KEYWORD)
    PG_KEYWORD("COALESCE", COL_NAME_KEYWORD)
    PG_KEYWORD("COLLATE", RESERVED_KEYWORD)
    PG_KEYWORD("COLLATION", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("COLUMN", RESERVED_KEYWORD)
    PG_KEYWORD("COMMENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("COMMENTS", UNRESERVED_KEYWORD)
    PG_KEYWORD("COMMIT", UNRESERVED_KEYWORD)
    PG_KEYWORD("COMMITTED", UNRESERVED_KEYWORD)
    PG_KEYWORD("CONCURRENTLY", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("CONFIGURATION", UNRESERVED_KEYWORD)
    PG_KEYWORD("CONNECTION", UNRESERVED_KEYWORD)
    PG_KEYWORD("CONSTRAINT", RESERVED_KEYWORD)
    PG_KEYWORD("CONSTRAINTS", UNRESERVED_KEYWORD)
    PG_KEYWORD("CONTENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("CONTINUE", UNRESERVED_KEYWORD)
    PG_KEYWORD("CONVERSION", UNRESERVED_KEYWORD)
    PG_KEYWORD("COPY", UNRESERVED_KEYWORD)
    PG_KEYWORD("COST", UNRESERVED_KEYWORD)
    PG_KEYWORD("CREATE", RESERVED_KEYWORD)
    PG_KEYWORD("CROSS", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("CSV", UNRESERVED_KEYWORD)
    PG_KEYWORD("CURRENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("CURRENT_CATALOG", RESERVED_KEYWORD)
    PG_KEYWORD("CURRENT_DATE", RESERVED_KEYWORD)
    PG_KEYWORD("CURRENT_ROLE", RESERVED_KEYWORD)
    PG_KEYWORD("CURRENT_SCHEMA", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("CURRENT_TIME", RESERVED_KEYWORD)
    PG_KEYWORD("CURRENT_TIMESTAMP", RESERVED_KEYWORD)
    PG_KEYWORD("CURRENT_USER", RESERVED_KEYWORD)
    PG_KEYWORD("CURSOR", UNRESERVED_KEYWORD)
    PG_KEYWORD("CYCLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("DATA", UNRESERVED_KEYWORD)
    PG_KEYWORD("DATABASE", UNRESERVED_KEYWORD)
    PG_TYPE("DATE")
    PG_KEYWORD("DAY", UNRESERVED_KEYWORD)
    PG_KEYWORD("DEALLOCATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("DEC", COL_NAME_KEYWORD)
    // PG_KEYWORD("DECIMAL", COL_NAME_KEYWORD)
    PG_TYPE("DECIMAL")
    PG_KEYWORD("DECLARE", UNRESERVED_KEYWORD)
    PG_KEYWORD("DEFAULT", RESERVED_KEYWORD)
    PG_KEYWORD("DEFAULTS", UNRESERVED_KEYWORD)
    PG_KEYWORD("DEFERRABLE", RESERVED_KEYWORD)
    PG_KEYWORD("DEFERRED", UNRESERVED_KEYWORD)
    PG_KEYWORD("DEFINER", UNRESERVED_KEYWORD)
    PG_KEYWORD("DELETE", UNRESERVED_KEYWORD)
    PG_KEYWORD("DELIMITER", UNRESERVED_KEYWORD)
    PG_KEYWORD("DELIMITERS", UNRESERVED_KEYWORD)
    PG_KEYWORD("DESC", RESERVED_KEYWORD)
    PG_KEYWORD("DICTIONARY", UNRESERVED_KEYWORD)
    PG_KEYWORD("DISABLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("DISCARD", UNRESERVED_KEYWORD)
    PG_KEYWORD("DISTINCT", RESERVED_KEYWORD)
    PG_KEYWORD("DO", RESERVED_KEYWORD)
    PG_KEYWORD("DOCUMENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("DOMAIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("DOUBLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("DROP", UNRESERVED_KEYWORD)
    PG_KEYWORD("EACH", UNRESERVED_KEYWORD)
    PG_KEYWORD("ELSE", RESERVED_KEYWORD)
    PG_KEYWORD("ENABLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("ENCODING", UNRESERVED_KEYWORD)
    PG_KEYWORD("ENCRYPTED", UNRESERVED_KEYWORD)
    PG_KEYWORD("END", RESERVED_KEYWORD)
    PG_KEYWORD("ENUM", UNRESERVED_KEYWORD)
    PG_KEYWORD("ESCAPE", UNRESERVED_KEYWORD)
    PG_KEYWORD("EVENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXCEPT", RESERVED_KEYWORD)
    PG_KEYWORD("EXCLUDE", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXCLUDING", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXCLUSIVE", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXECUTE", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXISTS", COL_NAME_KEYWORD)
    PG_KEYWORD("EXPLAIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXTENSION", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXTERNAL", UNRESERVED_KEYWORD)
    PG_KEYWORD("EXTRACT", COL_NAME_KEYWORD)
    PG_KEYWORD("FALSE", RESERVED_KEYWORD)
    PG_KEYWORD("FAMILY", UNRESERVED_KEYWORD)
    PG_KEYWORD("FETCH", RESERVED_KEYWORD)
    PG_KEYWORD("FILTER", UNRESERVED_KEYWORD)
    PG_KEYWORD("FIRST", UNRESERVED_KEYWORD)
    // PG_KEYWORD("FLOAT", COL_NAME_KEYWORD)
    PG_TYPE("FLOAT")
    PG_TYPE("FLOAT4")
    PG_TYPE("FLOAT8") // TODO: DOUBLE PRECISION
    PG_KEYWORD("FOLLOWING", UNRESERVED_KEYWORD)
    PG_KEYWORD("FOR", RESERVED_KEYWORD)
    PG_KEYWORD("FORCE", UNRESERVED_KEYWORD)
    PG_KEYWORD("FOREIGN", RESERVED_KEYWORD)
    PG_KEYWORD("FORWARD", UNRESERVED_KEYWORD)
    PG_KEYWORD("FREEZE", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("FROM", RESERVED_KEYWORD)
    PG_KEYWORD("FULL", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("FUNCTION", UNRESERVED_KEYWORD)
    PG_KEYWORD("FUNCTIONS", UNRESERVED_KEYWORD)
    PG_KEYWORD("GLOBAL", UNRESERVED_KEYWORD)
    PG_KEYWORD("GRANT", RESERVED_KEYWORD)
    PG_KEYWORD("GRANTED", UNRESERVED_KEYWORD)
    PG_KEYWORD("GREATEST", COL_NAME_KEYWORD)
    PG_KEYWORD("GROUP", RESERVED_KEYWORD)
    PG_KEYWORD("HANDLER", UNRESERVED_KEYWORD)
    PG_KEYWORD("HAVING", RESERVED_KEYWORD)
    PG_KEYWORD("HEADER", UNRESERVED_KEYWORD)
    PG_KEYWORD("HOLD", UNRESERVED_KEYWORD)
    PG_KEYWORD("HOUR", UNRESERVED_KEYWORD)
    PG_KEYWORD("IDENTITY", UNRESERVED_KEYWORD)
    PG_KEYWORD("IF", UNRESERVED_KEYWORD)
    PG_KEYWORD("ILIKE", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("IMMEDIATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("IMMUTABLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("IMPLICIT", UNRESERVED_KEYWORD)
    PG_KEYWORD("IMPORT", UNRESERVED_KEYWORD)
    PG_KEYWORD("IN", RESERVED_KEYWORD)
    PG_KEYWORD("INCLUDING", UNRESERVED_KEYWORD)
    PG_KEYWORD("INCREMENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("INDEX", UNRESERVED_KEYWORD)
    PG_KEYWORD("INDEXES", UNRESERVED_KEYWORD)
    PG_TYPE("INET")
    PG_KEYWORD("INHERIT", UNRESERVED_KEYWORD)
    PG_KEYWORD("INHERITS", UNRESERVED_KEYWORD)
    PG_KEYWORD("INITIALLY", RESERVED_KEYWORD)
    PG_KEYWORD("INLINE", UNRESERVED_KEYWORD)
    PG_KEYWORD("INNER", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("INOUT", COL_NAME_KEYWORD)
    PG_KEYWORD("INPUT", UNRESERVED_KEYWORD)
    PG_KEYWORD("INSENSITIVE", UNRESERVED_KEYWORD)
    PG_KEYWORD("INSERT", UNRESERVED_KEYWORD)
    PG_KEYWORD("INSTEAD", UNRESERVED_KEYWORD)
    // PG_KEYWORD("INT", COL_NAME_KEYWORD)
    PG_TYPE("INT")
    PG_TYPE("INT2")
    PG_TYPE("INT4")
    PG_TYPE("INT8")
    PG_TYPE("INTEGER")
    // PG_KEYWORD("INTEGER", COL_NAME_KEYWORD)
    PG_KEYWORD("INTERSECT", RESERVED_KEYWORD)
    // PG_KEYWORD("INTERVAL", COL_NAME_KEYWORD)
    PG_TYPE("INTERVAL")
    PG_KEYWORD("INTO", RESERVED_KEYWORD)
    PG_KEYWORD("INVOKER", UNRESERVED_KEYWORD)
    PG_KEYWORD("IS", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("ISNULL", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("ISOLATION", UNRESERVED_KEYWORD)
    PG_KEYWORD("JOIN", TYPE_FUNC_NAME_KEYWORD)
    PG_TYPE("JSON")
    PG_TYPE("JSONB")
    PG_KEYWORD("KEY", UNRESERVED_KEYWORD)
    PG_KEYWORD("LABEL", UNRESERVED_KEYWORD)
    PG_KEYWORD("LANGUAGE", UNRESERVED_KEYWORD)
    PG_KEYWORD("LARGE", UNRESERVED_KEYWORD)
    PG_KEYWORD("LAST", UNRESERVED_KEYWORD)
    PG_KEYWORD("LATERAL", RESERVED_KEYWORD)
    PG_KEYWORD("LEADING", RESERVED_KEYWORD)
    PG_KEYWORD("LEAKPROOF", UNRESERVED_KEYWORD)
    PG_KEYWORD("LEAST", COL_NAME_KEYWORD)
    PG_KEYWORD("LEFT", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("LEVEL", UNRESERVED_KEYWORD)
    PG_KEYWORD("LIKE", TYPE_FUNC_NAME_KEYWORD)
    PG_TYPE("LINE")
    PG_KEYWORD("LIMIT", RESERVED_KEYWORD)
    PG_KEYWORD("LISTEN", UNRESERVED_KEYWORD)
    PG_KEYWORD("LOAD", UNRESERVED_KEYWORD)
    PG_KEYWORD("LOCAL", UNRESERVED_KEYWORD)
    PG_KEYWORD("LOCALTIME", RESERVED_KEYWORD)
    PG_KEYWORD("LOCALTIMESTAMP", RESERVED_KEYWORD)
    PG_KEYWORD("LOCATION", UNRESERVED_KEYWORD)
    PG_KEYWORD("LOCK", UNRESERVED_KEYWORD)
    PG_KEYWORD("LOCKED", UNRESERVED_KEYWORD)
    PG_KEYWORD("LOGGED", UNRESERVED_KEYWORD)
    PG_TYPE("LSEG")
    PG_TYPE("MACADDR")
    PG_KEYWORD("MAPPING", UNRESERVED_KEYWORD)
    PG_KEYWORD("MATCH", UNRESERVED_KEYWORD)
    PG_KEYWORD("MATERIALIZED", UNRESERVED_KEYWORD)
    PG_KEYWORD("MAXVALUE", UNRESERVED_KEYWORD)
    PG_KEYWORD("MINUTE", UNRESERVED_KEYWORD)
    PG_KEYWORD("MINVALUE", UNRESERVED_KEYWORD)
    PG_KEYWORD("MODE", UNRESERVED_KEYWORD)
    PG_TYPE("MONEY")
    PG_KEYWORD("MONTH", UNRESERVED_KEYWORD)
    PG_KEYWORD("MOVE", UNRESERVED_KEYWORD)
    PG_KEYWORD("NAME", UNRESERVED_KEYWORD)
    PG_KEYWORD("NAMES", UNRESERVED_KEYWORD)
    PG_KEYWORD("NATIONAL", COL_NAME_KEYWORD)
    PG_KEYWORD("NATURAL", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("NCHAR", COL_NAME_KEYWORD)
    PG_KEYWORD("NEXT", UNRESERVED_KEYWORD)
    PG_KEYWORD("NO", UNRESERVED_KEYWORD)
    PG_KEYWORD("NONE", COL_NAME_KEYWORD)
    PG_KEYWORD("NOT", RESERVED_KEYWORD)
    PG_KEYWORD("NOTHING", UNRESERVED_KEYWORD)
    PG_KEYWORD("NOTIFY", UNRESERVED_KEYWORD)
    PG_KEYWORD("NOTNULL", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("NOWAIT", UNRESERVED_KEYWORD)
    PG_KEYWORD("NULL", RESERVED_KEYWORD)
    PG_KEYWORD("NULLIF", COL_NAME_KEYWORD)
    PG_KEYWORD("NULLS", UNRESERVED_KEYWORD)
    // PG_KEYWORD("NUMERIC", COL_NAME_KEYWORD)
    PG_TYPE("NUMERIC")
    PG_KEYWORD("OBJECT", UNRESERVED_KEYWORD)
    PG_KEYWORD("OF", UNRESERVED_KEYWORD)
    PG_KEYWORD("OFF", UNRESERVED_KEYWORD)
    PG_KEYWORD("OFFSET", RESERVED_KEYWORD)
    PG_KEYWORD("OIDS", UNRESERVED_KEYWORD)
    PG_KEYWORD("ON", RESERVED_KEYWORD)
    PG_KEYWORD("ONLY", RESERVED_KEYWORD)
    PG_KEYWORD("OPERATOR", UNRESERVED_KEYWORD)
    PG_KEYWORD("OPTION", UNRESERVED_KEYWORD)
    PG_KEYWORD("OPTIONS", UNRESERVED_KEYWORD)
    PG_KEYWORD("OR", RESERVED_KEYWORD)
    PG_KEYWORD("ORDER", RESERVED_KEYWORD)
    PG_KEYWORD("ORDINALITY", UNRESERVED_KEYWORD)
    PG_KEYWORD("OUT", COL_NAME_KEYWORD)
    PG_KEYWORD("OUTER", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("OVER", UNRESERVED_KEYWORD)
    PG_KEYWORD("OVERLAPS", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("OVERLAY", COL_NAME_KEYWORD)
    PG_KEYWORD("OWNED", UNRESERVED_KEYWORD)
    PG_KEYWORD("OWNER", UNRESERVED_KEYWORD)
    PG_KEYWORD("PARSER", UNRESERVED_KEYWORD)
    PG_KEYWORD("PARTIAL", UNRESERVED_KEYWORD)
    PG_KEYWORD("PARTITION", UNRESERVED_KEYWORD)
    PG_KEYWORD("PASSING", UNRESERVED_KEYWORD)
    PG_KEYWORD("PASSWORD", UNRESERVED_KEYWORD)
    PG_TYPE("PATH")
    PG_TYPE("PG_LSN")
    PG_KEYWORD("PLACING", RESERVED_KEYWORD)
    PG_KEYWORD("PLANS", UNRESERVED_KEYWORD)
    PG_TYPE("POINT")
    PG_KEYWORD("POLICY", UNRESERVED_KEYWORD)
    PG_TYPE("POLYGON")
    PG_KEYWORD("POSITION", COL_NAME_KEYWORD)
    PG_KEYWORD("PRECEDING", UNRESERVED_KEYWORD)
    PG_KEYWORD("PRECISION", COL_NAME_KEYWORD)
    PG_KEYWORD("PREPARE", UNRESERVED_KEYWORD)
    PG_KEYWORD("PREPARED", UNRESERVED_KEYWORD)
    PG_KEYWORD("PRESERVE", UNRESERVED_KEYWORD)
    PG_KEYWORD("PRIMARY", RESERVED_KEYWORD)
    PG_KEYWORD("PRIOR", UNRESERVED_KEYWORD)
    PG_KEYWORD("PRIVILEGES", UNRESERVED_KEYWORD)
    PG_KEYWORD("PROCEDURAL", UNRESERVED_KEYWORD)
    PG_KEYWORD("PROCEDURE", UNRESERVED_KEYWORD)
    PG_KEYWORD("PROGRAM", UNRESERVED_KEYWORD)
    PG_KEYWORD("QUOTE", UNRESERVED_KEYWORD)
    PG_KEYWORD("RANGE", UNRESERVED_KEYWORD)
    PG_KEYWORD("READ", UNRESERVED_KEYWORD)
    // PG_KEYWORD("REAL", COL_NAME_KEYWORD)
    PG_TYPE("REAL")
    PG_KEYWORD("REASSIGN", UNRESERVED_KEYWORD)
    PG_KEYWORD("RECHECK", UNRESERVED_KEYWORD)
    PG_KEYWORD("RECURSIVE", UNRESERVED_KEYWORD)
    PG_KEYWORD("REF", UNRESERVED_KEYWORD)
    PG_KEYWORD("REFERENCES", RESERVED_KEYWORD)
    PG_KEYWORD("REFRESH", UNRESERVED_KEYWORD)
    PG_KEYWORD("REINDEX", UNRESERVED_KEYWORD)
    PG_KEYWORD("RELATIVE", UNRESERVED_KEYWORD)
    PG_KEYWORD("RELEASE", UNRESERVED_KEYWORD)
    PG_KEYWORD("RENAME", UNRESERVED_KEYWORD)
    PG_KEYWORD("REPEATABLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("REPLACE", UNRESERVED_KEYWORD)
    PG_KEYWORD("REPLICA", UNRESERVED_KEYWORD)
    PG_KEYWORD("RESET", UNRESERVED_KEYWORD)
    PG_KEYWORD("RESTART", UNRESERVED_KEYWORD)
    PG_KEYWORD("RESTRICT", UNRESERVED_KEYWORD)
    PG_KEYWORD("RETURNING", RESERVED_KEYWORD)
    PG_KEYWORD("RETURNS", UNRESERVED_KEYWORD)
    PG_KEYWORD("REVOKE", UNRESERVED_KEYWORD)
    PG_KEYWORD("RIGHT", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("ROLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("ROLLBACK", UNRESERVED_KEYWORD)
    PG_KEYWORD("ROW", COL_NAME_KEYWORD)
    PG_KEYWORD("ROWS", UNRESERVED_KEYWORD)
    PG_KEYWORD("RULE", UNRESERVED_KEYWORD)
    PG_KEYWORD("SAVEPOINT", UNRESERVED_KEYWORD)
    PG_KEYWORD("SCHEMA", UNRESERVED_KEYWORD)
    PG_KEYWORD("SCROLL", UNRESERVED_KEYWORD)
    PG_KEYWORD("SEARCH", UNRESERVED_KEYWORD)
    PG_KEYWORD("SECOND", UNRESERVED_KEYWORD)
    PG_KEYWORD("SECURITY", UNRESERVED_KEYWORD)
    PG_KEYWORD("SELECT", RESERVED_KEYWORD)
    PG_KEYWORD("SEQUENCE", UNRESERVED_KEYWORD)
    PG_KEYWORD("SEQUENCES", UNRESERVED_KEYWORD)
    PG_TYPE("SERIAL")
    PG_TYPE("SERIAL2")
    PG_TYPE("SERIAL4")
    PG_TYPE("SERIAL8")
    PG_KEYWORD("SERIALIZABLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("SERVER", UNRESERVED_KEYWORD)
    PG_KEYWORD("SESSION", UNRESERVED_KEYWORD)
    PG_KEYWORD("SESSION_USER", RESERVED_KEYWORD)
    PG_KEYWORD("SET", UNRESERVED_KEYWORD)
    PG_KEYWORD("SETOF", COL_NAME_KEYWORD)
    PG_KEYWORD("SHARE", UNRESERVED_KEYWORD)
    PG_KEYWORD("SHOW", UNRESERVED_KEYWORD)
    PG_KEYWORD("SIMILAR", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("SIMPLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("SKIP", UNRESERVED_KEYWORD)
    // PG_KEYWORD("SMALLINT", COL_NAME_KEYWORD)
    PG_TYPE("SMALLINT")
    PG_TYPE("SMALLSERIAL")
    PG_KEYWORD("SNAPSHOT", UNRESERVED_KEYWORD)
    PG_KEYWORD("SOME", RESERVED_KEYWORD)
    PG_KEYWORD("STABLE", UNRESERVED_KEYWORD)
    PG_KEYWORD("STANDALONE", UNRESERVED_KEYWORD)
    PG_KEYWORD("START", UNRESERVED_KEYWORD)
    PG_KEYWORD("STATEMENT", UNRESERVED_KEYWORD)
    PG_KEYWORD("STATISTICS", UNRESERVED_KEYWORD)
    PG_KEYWORD("STDIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("STDOUT", UNRESERVED_KEYWORD)
    PG_KEYWORD("STORAGE", UNRESERVED_KEYWORD)
    PG_KEYWORD("STRICT", UNRESERVED_KEYWORD)
    PG_KEYWORD("STRIP", UNRESERVED_KEYWORD)
    PG_KEYWORD("SUBSTRING", COL_NAME_KEYWORD)
    PG_KEYWORD("SYMMETRIC", RESERVED_KEYWORD)
    PG_KEYWORD("SYSID", UNRESERVED_KEYWORD)
    PG_KEYWORD("SYSTEM", UNRESERVED_KEYWORD)
    PG_KEYWORD("TABLE", RESERVED_KEYWORD)
    PG_KEYWORD("TABLES", UNRESERVED_KEYWORD)
    PG_KEYWORD("TABLESPACE", UNRESERVED_KEYWORD)
    PG_KEYWORD("TEMP", UNRESERVED_KEYWORD)
    PG_KEYWORD("TEMPLATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("TEMPORARY", UNRESERVED_KEYWORD)
    // PG_KEYWORD("TEXT", UNRESERVED_KEYWORD)
    PG_TYPE("TEXT")
    PG_KEYWORD("THEN", RESERVED_KEYWORD)
    // PG_KEYWORD("TIME", COL_NAME_KEYWORD)
    PG_TYPE("TIME")
    // PG_KEYWORD("TIMESTAMP", COL_NAME_KEYWORD)
    PG_TYPE("TIMESTAMP")
    PG_KEYWORD("TO", RESERVED_KEYWORD)
    PG_KEYWORD("TRAILING", RESERVED_KEYWORD)
    PG_KEYWORD("TRANSACTION", UNRESERVED_KEYWORD)
    PG_KEYWORD("TREAT", COL_NAME_KEYWORD)
    PG_KEYWORD("TRIGGER", UNRESERVED_KEYWORD)
    PG_KEYWORD("TRIM", COL_NAME_KEYWORD)
    PG_KEYWORD("TRUE", RESERVED_KEYWORD)
    PG_KEYWORD("TRUNCATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("TRUSTED", UNRESERVED_KEYWORD)
    PG_TYPE("TSQUERY")
    PG_TYPE("TSVECTOR")
    PG_TYPE("TXID_SNAPSHOT")
    PG_KEYWORD("TYPE", UNRESERVED_KEYWORD)
    PG_KEYWORD("TYPES", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNBOUNDED", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNCOMMITTED", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNENCRYPTED", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNION", RESERVED_KEYWORD)
    PG_KEYWORD("UNIQUE", RESERVED_KEYWORD)
    PG_KEYWORD("UNKNOWN", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNLISTEN", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNLOGGED", UNRESERVED_KEYWORD)
    PG_KEYWORD("UNTIL", UNRESERVED_KEYWORD)
    PG_KEYWORD("UPDATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("USER", RESERVED_KEYWORD)
    PG_KEYWORD("USING", RESERVED_KEYWORD)
    PG_TYPE("UUID")
    PG_KEYWORD("VACUUM", UNRESERVED_KEYWORD)
    PG_KEYWORD("VALID", UNRESERVED_KEYWORD)
    PG_KEYWORD("VALIDATE", UNRESERVED_KEYWORD)
    PG_KEYWORD("VALIDATOR", UNRESERVED_KEYWORD)
    PG_KEYWORD("VALUE", UNRESERVED_KEYWORD)
    PG_KEYWORD("VALUES", COL_NAME_KEYWORD)
    PG_TYPE("VARBIT")
    // PG_KEYWORD("VARCHAR", COL_NAME_KEYWORD)
    PG_TYPE("VARCHAR")
    PG_KEYWORD("VARIADIC", RESERVED_KEYWORD)
    PG_KEYWORD("VARYING", UNRESERVED_KEYWORD)
    PG_KEYWORD("VERBOSE", TYPE_FUNC_NAME_KEYWORD)
    PG_KEYWORD("VERSION", UNRESERVED_KEYWORD)
    PG_KEYWORD("VIEW", UNRESERVED_KEYWORD)
    PG_KEYWORD("VIEWS", UNRESERVED_KEYWORD)
    PG_KEYWORD("VOLATILE", UNRESERVED_KEYWORD)
    PG_KEYWORD("WHEN", RESERVED_KEYWORD)
    PG_KEYWORD("WHERE", RESERVED_KEYWORD)
    PG_KEYWORD("WHITESPACE", UNRESERVED_KEYWORD)
    PG_KEYWORD("WINDOW", RESERVED_KEYWORD)
    PG_KEYWORD("WITH", RESERVED_KEYWORD)
    PG_KEYWORD("WITHIN", UNRESERVED_KEYWORD)
    PG_KEYWORD("WITHOUT", UNRESERVED_KEYWORD)
    PG_KEYWORD("WORK", UNRESERVED_KEYWORD)
    PG_KEYWORD("WRAPPER", UNRESERVED_KEYWORD)
    PG_KEYWORD("WRITE", UNRESERVED_KEYWORD)
    // PG_KEYWORD("XML", UNRESERVED_KEYWORD)
    PG_TYPE("XML")
    PG_KEYWORD("XMLATTRIBUTES", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLCONCAT", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLELEMENT", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLEXISTS", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLFOREST", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLPARSE", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLPI", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLROOT", COL_NAME_KEYWORD)
    PG_KEYWORD("XMLSERIALIZE", COL_NAME_KEYWORD)
    PG_KEYWORD("YEAR", UNRESERVED_KEYWORD)
    PG_KEYWORD("YES", UNRESERVED_KEYWORD)
    PG_KEYWORD("ZONE", UNRESERVED_KEYWORD)
};
#undef PG_KEYWORD
#undef PG_TYPE

static void pgfinalize(LexerData *data)
{
    PgLexerData *mydata;

    mydata = (PgLexerData *) data;
    if (NULL != mydata->dolqstart) {
        free(mydata->dolqstart);
    }
}

static int pglex(YYLEX_ARGS)
{
    PgLexerData *mydata;
    const PgLexerOption *myoptions;

    (void) ctxt;
    mydata = (PgLexerData *) data;
    myoptions = (const PgLexerOption *) options;
    while (YYCURSOR < YYLIMIT) {
        YYTEXT = YYCURSOR;

/*!re2c
re2c:yyfill:check = 0;
re2c:yyfill:enable = 0;

space = [ \t\n\r\f];
horiz_space = [ \t\f];
newline = [\n\r];
non_newline = [^\n\r];
comment = ("--" non_newline*);
whitespace = (space+ | comment);

self = [,()\[\].;\:\+\-\*\/\%\^\<\>\=];
op_chars = [\~\!\@\#\^\&\|\`\?\+\-\*\/\%\<\>\=];
operator = op_chars+;

special_whitespace = (space+ | comment newline);
horiz_whitespace = (horiz_space | comment);
whitespace_with_newline = (horiz_whitespace* newline special_whitespace*);

quote = ['];
quotestop = quote whitespace*;
quotecontinue = quote whitespace_with_newline quote;
quotefail = quote whitespace* "-";

xbstart = [bB] quote;
xbinside = [^']*;
// should be xbinside = [01]*; but we don't take care of string content (same as pgsql, it checks this at a different level)

xhstart = [xX] quote;
xhinside = [^']*;
// should be xhinside = [0-9a-fA-F]*; but we don't take care of string content (same as pgsql, it checks this at a different level)

xnstart = [nN] quote;

xestart = [eE] quote;
xeinside = [^\\']+;
xeescape = [\\][^0-7];
xeoctesc = [\\][0-7]{1,3};
xehexesc = [\\][x][0-9A-Fa-f]{1,2};
xeunicode = [\\]([u][0-9A-Fa-f]{4}|[U][0-9A-Fa-f]{8});
xeunicodefail = [\\]([u][0-9A-Fa-f]{0,3}|[U][0-9A-Fa-f]{0,7});

xqstart = quote;
xqdouble = quote quote;
xqinside = [^']+;

dolq_start = [A-Za-z\200-\377_];
dolq_cont = [A-Za-z\200-\377_0-9];
dolqdelim = [$] (dolq_start dolq_cont*)? [$];
dolqfailed = [$] dolq_start dolq_cont*;
dolqinside = [^$]+;

dquote = ["];
xdstart = dquote;
xdstop = dquote;
xddouble = dquote dquote;
xdinside = [^"]+;

uescape = 'uescape' whitespace* quote [^'] quote;
uescapefail = 'uescape' whitespace* "-" | 'uescape' whitespace* quote [^'] | 'uescape' whitespace* quote | 'uescape' whitespace* | 'uescap' | 'uesca' | 'uesc' | 'ues' | 'ue' | 'u';

xuistart = [uU][&]dquote;
xusstart = [uU][&]quote;
xustop1 = uescapefail?;
xustop2 = uescape;
xufailed = [uU][&];

xcstart = "/*" op_chars*;
xcstop = "*"+"/";
xcinside = [^*/]+;

digit = [0-9];
ident_start = [A-Za-z\200-\377_];
ident_cont = [A-Za-z\200-\377_0-9\$];
identifier = ident_start ident_cont*;

typecast = "::";
dot_dot = "..";
colon_equals = ":=";
equals_greater = "=>";
less_equals = "<=";
greater_equals = ">=";
less_greater = "<>";
not_equals = "!=";

integer = digit+;
decimal = ((digit* "." digit+) | (digit+ "." digit*));
decimalfail = digit+ "..";
real = (integer|decimal)[Ee][-+]?digit+;
realfail1 = (integer|decimal)[Ee];
realfail2 = (integer|decimal)[Ee][-+];

param = "$" integer;

other = [^];

/**
 * Difference with original pgsql lexer: split whitespace in two distinct cases:
 * - comment
 * - space
 * Needed to highlight oneline comment.
 **/
<INITIAL> comment {
    TOKEN(COMMENT_SINGLE);
}

<INITIAL> space {
    TOKEN(IGNORABLE);
}

<INITIAL> xcstart {
    BEGIN(xc);
    yyless(2);
    TOKEN(COMMENT_MULTILINE);
}

<xc> xcstart {
    yyless(2);
    TOKEN(COMMENT_MULTILINE);
}

<xc> xcstop {
    BEGIN(INITIAL);
    TOKEN(COMMENT_MULTILINE);
}

<xc> xcinside {
    TOKEN(COMMENT_MULTILINE);
}

<xc> op_chars  {
    TOKEN(COMMENT_MULTILINE);
}

<xc> [*]+ {
    TOKEN(COMMENT_MULTILINE);
}

// <xc><<EOF>>

<INITIAL> xbstart {
    BEGIN(xb);
    TOKEN(NUMBER_BINARY);
}

<xb> quotestop | quotefail {
    yyless(1);
    BEGIN(INITIAL);
    TOKEN(NUMBER_BINARY);
}

<xb> xbinside {
    TOKEN(NUMBER_BINARY);
}

<xh> xhinside {
    TOKEN(NUMBER_HEXADECIMAL);
}

// <xh>{quotecontinue} | <xb>{quotecontinue}

// <xb><<EOF>>

<INITIAL> xhstart {
    BEGIN(xh);
    TOKEN(NUMBER_HEXADECIMAL);
}

<xh> quotestop | quotefail {
    yyless(1);
    BEGIN(INITIAL);
    TOKEN(NUMBER_HEXADECIMAL);
}

// <xh><<EOF>>

<INITIAL> xnstart {
    BEGIN(xq);
    TOKEN(STRING_SINGLE);
}

<INITIAL> xqstart {
    if (myoptions->standard_conforming_strings) {
        BEGIN(xq);
    } else {
        BEGIN(xe);
    }
    TOKEN(STRING_SINGLE);
}

<INITIAL> xestart {
    BEGIN(xe);
    TOKEN(STRING_SINGLE);
}

<INITIAL> xusstart {
//     if (!myoptions->standard_conforming_strings)
    BEGIN(xus);
    TOKEN(STRING_SINGLE);
}

<xq,xe> quotestop | quotefail {
    yyless(1);
    BEGIN(INITIAL);
    TOKEN(STRING_SINGLE);
}

<xus> quotestop | quotefail {
    yyless(1);
    BEGIN(xusend);
    TOKEN(STRING_SINGLE);
}

<xusend> whitespace {
    TOKEN(STRING_SINGLE);
}

<xusend> other | xustop1 {
    yyless(0);
    BEGIN(INITIAL);
    TOKEN(STRING_SINGLE);
}

<xusend> xustop2 {
    BEGIN(INITIAL);
    TOKEN(STRING_SINGLE);
}

<xq,xe,xus> xqdouble {
    TOKEN(STRING_SINGLE);
}

<xq,xus> xqinside {
    TOKEN(STRING_SINGLE);
}

<xe> xeinside {
    TOKEN(STRING_SINGLE);
}

<xe> xeunicode {
#if 0
    if (is_utf16_surrogate_first(c)) {
        BEGIN(xeu);
    } else {
        // invalid
    }
#else
//     BEGIN(xeu);
#endif
    TOKEN(ESCAPED_CHAR);
}

<xeu> xeunicode {
    BEGIN(xe);
    TOKEN(ESCAPED_CHAR);
}

// <xeu> .
// <xeu> \n
// <xeu> <<EOF>>
// <xe,xeu> xeunicodefail

<xe> xeescape {
    TOKEN(ESCAPED_CHAR);
}

<xe> xeoctesc {
    TOKEN(ESCAPED_CHAR);
}

<xe> xehexesc {
    TOKEN(ESCAPED_CHAR);
}

<xq,xe,xus> quotecontinue {
    TOKEN(STRING_SINGLE);
}

<xe> . {
    TOKEN(STRING_SINGLE);
}

// <xq,xe,xus><<EOF>>

<INITIAL> dolqdelim {
    BEGIN(xdolq);
    mydata->dolqstart_len = YYCURSOR - YYTEXT;
    mydata->dolqstart = strndup((char *) YYTEXT, mydata->dolqstart_len);
    TOKEN(STRING_SINGLE);
}

<INITIAL> dolqfailed {
    yyless(1);
    TOKEN(IGNORABLE);
}

<xdolq> dolqdelim {
    if (((size_t) (YYCURSOR - YYTEXT)) == mydata->dolqstart_len && 0 == memcmp(YYTEXT, mydata->dolqstart, mydata->dolqstart_len)) {
        free(mydata->dolqstart);
        mydata->dolqstart = NULL;
        BEGIN(INITIAL);
    } else {
        yyless((YYCURSOR - YYTEXT) - 1);
    }
    TOKEN(STRING_SINGLE);
}

<xdolq> dolqinside {
    TOKEN(STRING_SINGLE);
}

<xdolq> dolqfailed {
    TOKEN(STRING_SINGLE);
}

<xdolq> . {
    TOKEN(STRING_SINGLE);
}

// <xdolq><<EOF>>

<INITIAL> xdstart {
    BEGIN(xd);
    TOKEN(STRING_SINGLE);
}

<INITIAL> xuistart {
    BEGIN(xui);
    TOKEN(STRING_SINGLE);
}

<xd> xdstop {
    BEGIN(INITIAL);
    TOKEN(STRING_SINGLE);
}

<xui> dquote {
    yyless(1);
    BEGIN(xuiend);
    TOKEN(STRING_SINGLE);
}

<xuiend> whitespace {
    TOKEN(IGNORABLE);
}

<xuiend> other | xustop1 {
    yyless(0);
    BEGIN(INITIAL);
    TOKEN(STRING_SINGLE);
}

<xuiend> xustop2 {
    BEGIN(INITIAL);
    TOKEN(STRING_SINGLE);
}

<xd,xui> xddouble  {
    TOKEN(STRING_SINGLE);
}

<xd,xui> xdinside {
    TOKEN(STRING_SINGLE);
}

// <xd,xui><<EOF>>

<INITIAL> xufailed {
    yyless(1);
    TOKEN(STRING_SINGLE);
}

<INITIAL> typecast | dot_dot | colon_equals | equals_greater | less_equals | greater_equals | less_greater | not_equals | self {
    TOKEN(OPERATOR);
}

<INITIAL> operator {
    // TODO: stricter
    TOKEN(OPERATOR);
}

<INITIAL> param {
    TOKEN(NAME_VARIABLE);
}

<INITIAL> integer {
    TOKEN(NUMBER_DECIMAL);
}

<INITIAL> decimal {
    TOKEN(NUMBER_FLOAT);
}

<INITIAL> decimalfail {
    yyless((YYCURSOR - YYTEXT) - 2);
    TOKEN(NUMBER_DECIMAL);
}

<INITIAL> real {
    TOKEN(NUMBER_FLOAT);
}

<INITIAL> realfail1 {
    yyless((YYCURSOR - YYTEXT) - 1);
    TOKEN(NUMBER_FLOAT);
}

<INITIAL> realfail2 {
    yyless((YYCURSOR - YYTEXT) - 2);
    TOKEN(NUMBER_FLOAT);
}

<INITIAL> identifier {
    named_element_t key = { (char *) YYTEXT, YYLENG };
    typed_named_element_t *match;

    if (NULL != (match = bsearch(&key, keywords, ARRAY_SIZE(keywords), sizeof(keywords[0]), named_elements_casecmp))) {
        if (myoptions->uppercase_keywords/* && KEYWORD == match->type*/) {
            TOKEN_OUTSRC(match->type, (const YYCTYPE *) match->ne.name, (const YYCTYPE *) match->ne.name + match->ne.name_len);
        } else {
            TOKEN(match->type);
        }
    } else {
        TOKEN(IGNORABLE);
    }
}

<INITIAL> other {
    TOKEN(IGNORABLE);
}

// <<EOF>>
*/
    }
    DONE();
}

LexerImplementation postgresql_lexer = {
    "PostgreSQL",
    "Lexer for the PostgreSQL dialect of SQL",
    (const char * const []) { "pgsql", "postgre", NULL },
    NULL, // "*.sql" but it may conflict with future mysql & co?
    (const char * const []) { "text/x-postgresql", NULL },
    NULL, // interpreters
    NULL, // analyze
    NULL, // init
    pglex,
    pgfinalize,
    sizeof(PgLexerData),
    (/*const*/ LexerOption /*const*/ []) {
        { S("uppercase_keywords"),          OPT_TYPE_BOOL, offsetof(PgLexerOption, uppercase_keywords),          OPT_DEF_BOOL(0), "When true, PostgreSQL keywords are uppercased" },
        { S("standard_conforming_strings"), OPT_TYPE_BOOL, offsetof(PgLexerOption, standard_conforming_strings), OPT_DEF_BOOL(1), "To treat backslashes literally in ordinary string literals (`'...'`) or not" },
        END_OF_OPTIONS
    },
    NULL, // dependencies
    NULL, // yypush_parse
    NULL, // yypstate_new
    NULL, // yypstate_delete
};
